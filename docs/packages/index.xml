<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Stars</title>
    <link>https://itssamuelrowe.github.io/binarystars/packages/</link>
    <description>Recent content on Binary Stars</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://itssamuelrowe.github.io/binarystars/packages/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://itssamuelrowe.github.io/binarystars/packages/declaring-packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://itssamuelrowe.github.io/binarystars/packages/declaring-packages/</guid>
      <description>To create a package you need to use the package statement at the beginning of your source file.
Here is the general form of the package statement.
package qualifiedName;  Here, the qualifiedName represents the name you assigned your package.
Here is an example of a package statement.
package example;  The package statement should always be the very first statement in your source file. The package statement creates a namespace identified by the qualified name you specify.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://itssamuelrowe.github.io/binarystars/packages/naming-conventions-for-packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://itssamuelrowe.github.io/binarystars/packages/naming-conventions-for-packages/</guid>
      <description>You can use any identifier you wish to name your packages. However, we recommend you to follow these naming conventions when you create your packages.
 Packages are usually named using the authors domain name. The domain name is written backwards to obtain the package name.  For example, imagine you own the domain example.com. You can create a package named com.example for all your packages.
Using your domain name allows you to create package names which are unique from the packages created by other programmers around the world.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://itssamuelrowe.github.io/binarystars/packages/understanding-packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://itssamuelrowe.github.io/binarystars/packages/understanding-packages/</guid>
      <description>A package is a group of related classes, interfaces, annotations and enumerations bundled together. Henceforth, when we refer to classes in this chapter we mean to include other components such as interfaces, annotations and enumerations, unless stated otherwise.
Packages are like containers that provide your classes a name space. For example, a package allows you to create two classes named Scanner. You simply need to store the classes in different packages.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://itssamuelrowe.github.io/binarystars/packages/understanding-qualified-names/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://itssamuelrowe.github.io/binarystars/packages/understanding-qualified-names/</guid>
      <description>You can create a hierarchy of packages using a qualified name. We mentioned this term in the previous section without going into its details.
A qualified name is a sequence of identifiers separated by dots. Here are some examples of qualified names.
java.lang java.util java.io com.onecube com.onecube.model com.onecube.module.storage zen.core javafx.stage  Here is the general form of a hierarchical package statement.
package level1.level2.level3;  Each identifier in a qualified name, separated by a dot, creates a node or level in your hierarchy.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://itssamuelrowe.github.io/binarystars/packages/understanding-the-classpath-environment-variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://itssamuelrowe.github.io/binarystars/packages/understanding-the-classpath-environment-variable/</guid>
      <description>Your packages should be organized correspondingly in your directories. But how does the Java Virtual Machine (JVM) determine which directory to look for your packages?
By default Java looks for packages in the current working directory, the directory from where you are invoking the JVM. Further, the Java Virtual Machine looks for packages in the directories listed in the classpath of the application. You can specify the classpath for an application in two ways.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://itssamuelrowe.github.io/binarystars/packages/working-with-the-import-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://itssamuelrowe.github.io/binarystars/packages/working-with-the-import-statement/</guid>
      <description>You have learnt how packages allow you to keep your classes organized. However, as you have seen accessing classes from different packages require fully qualified names, which means you have to type so much just to refere a class! For this reason, Java provides the import statement.
The general form of the import statement is shown here.
import qualifiedName;  Here, the qualified name refers to the class which you want to import.</description>
    </item>
    
  </channel>
</rss>